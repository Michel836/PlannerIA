"""
ü§ñ Assistant IA Conversationnel - PlannerIA
Assistant intelligent pour analyse de projets, recommandations et optimisations
"""

import streamlit as st
import asyncio
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import json
import re
from datetime import datetime
import numpy as np
from .predictive_engine import ai_predictor, ProjectDomain


class ConversationType(Enum):
    PROJECT_ANALYSIS = "analyse_projet"
    OPTIMIZATION = "optimisation"
    RISK_ASSESSMENT = "evaluation_risques"
    TEAM_PLANNING = "planification_equipe"
    BUDGET_PLANNING = "planification_budget"
    GENERAL_ADVICE = "conseil_general"


@dataclass
class ConversationContext:
    """Contexte de la conversation"""
    user_id: str
    session_id: str
    project_context: Optional[Dict[str, Any]] = None
    conversation_history: List[Dict[str, Any]] = None
    user_preferences: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.conversation_history is None:
            self.conversation_history = []
        if self.user_preferences is None:
            self.user_preferences = {}


class AIConversationalAssistant:
    """Assistant IA conversationnel pour PlannerIA"""
    
    def __init__(self):
        self.context = None
        self.intent_patterns = self._initialize_intent_patterns()
        self.response_templates = self._initialize_response_templates()
        self.knowledge_base = self._initialize_knowledge_base()
        
    def _initialize_intent_patterns(self) -> Dict[str, List[str]]:
        """Initialise les patterns de reconnaissance d'intention"""
        return {
            ConversationType.PROJECT_ANALYSIS.value: [
                r"analys[er|e] (?:mon|le) projet",
                r"que penses-tu de (?:mon|ce) projet",
                r"√©valuer? (?:mon|le) projet",
                r"faisabilit√© d[ue] projet",
                r"chances de succ√®s",
                r"projet .* avec .* d√©veloppeurs?"
            ],
            ConversationType.OPTIMIZATION.value: [
                r"optimis[er|ation]",
                r"am√©liorer (?:mon|le) projet",
                r"comment faire mieux",
                r"r√©duire les co√ªts?",
                r"acc√©l√©rer le d√©veloppement",
                r"plus efficace"
            ],
            ConversationType.RISK_ASSESSMENT.value: [
                r"risques?",
                r"dangers?",
                r"probl√®mes? potentiels?",
                r"qu'est-ce qui peut mal se passer",
                r"mitigation",
                r"s√©curiser le projet"
            ],
            ConversationType.TEAM_PLANNING.value: [
                r"√©quipe",
                r"d√©veloppeurs?",
                r"ressources? humaines?",
                r"combien de personnes?",
                r"comp√©tences? n√©cessaires?",
                r"recrutement"
            ],
            ConversationType.BUDGET_PLANNING.value: [
                r"budget",
                r"co√ªt",
                r"prix",
                r"combien √ßa co√ªte",
                r"financement",
                r"rentabilit√©"
            ]
        }
    
    def _initialize_response_templates(self) -> Dict[str, List[str]]:
        """Initialise les templates de r√©ponse"""
        return {
            'greeting': [
                "üëã Salut ! Je suis votre assistant IA PlannerIA. Comment puis-je vous aider avec votre projet ?",
                "ü§ñ Bonjour ! Pr√™t √† optimiser votre projet ensemble ?",
                "‚ú® Hello ! Votre assistant intelligent PlannerIA √† votre service !"
            ],
            'analysis_intro': [
                "üîç Parfait ! Laissez-moi analyser votre projet...",
                "üìä Excellente question ! Je vais examiner tous les aspects...",
                "üéØ Int√©ressant ! Voici mon analyse d√©taill√©e..."
            ],
            'optimization_intro': [
                "‚ö° Je vois plusieurs opportunit√©s d'optimisation...",
                "üöÄ Voici comment am√©liorer votre projet...",
                "üí° J'ai quelques suggestions brillantes pour vous..."
            ],
            'risk_intro': [
                "‚ö†Ô∏è Voici les risques que j'identifie...",
                "üõ°Ô∏è Parlons des points de vigilance...",
                "üîç Mon analyse des risques r√©v√®le..."
            ]
        }
    
    def _initialize_knowledge_base(self) -> Dict[str, Any]:
        """Initialise la base de connaissances"""
        return {
            'best_practices': {
                'agile': {
                    'description': "M√©thodologie agile pour projets adaptatifs",
                    'benefits': ["Flexibilit√©", "Feedback rapide", "Livraisons fr√©quentes"],
                    'when_to_use': "Projets avec requirements √©volutifs"
                },
                'devops': {
                    'description': "Int√©gration d√©veloppement et op√©rations",
                    'benefits': ["D√©ploiements rapides", "Qualit√©", "Automatisation"],
                    'when_to_use': "Projets n√©cessitant des d√©ploiements fr√©quents"
                },
                'microservices': {
                    'description': "Architecture en services distribu√©s",
                    'benefits': ["Scalabilit√©", "Ind√©pendance", "Technologie diverse"],
                    'when_to_use': "Grandes applications complexes"
                }
            },
            'technologies': {
                'react': {'type': 'frontend', 'complexity': 0.6, 'learning_curve': 0.7},
                'vue': {'type': 'frontend', 'complexity': 0.5, 'learning_curve': 0.5},
                'angular': {'type': 'frontend', 'complexity': 0.8, 'learning_curve': 0.9},
                'node.js': {'type': 'backend', 'complexity': 0.5, 'learning_curve': 0.6},
                'python': {'type': 'backend', 'complexity': 0.4, 'learning_curve': 0.4},
                'java': {'type': 'backend', 'complexity': 0.7, 'learning_curve': 0.8}
            },
            'domain_expertise': {
                'ecommerce': {
                    'key_features': ['Catalogue produits', 'Panier', 'Paiement', 'Gestion stocks'],
                    'challenges': ['Scalabilit√©', 'S√©curit√© paiements', 'UX mobile'],
                    'typical_duration': '4-8 mois',
                    'team_size': '5-10 personnes'
                },
                'fintech': {
                    'key_features': ['Transactions', 'KYC', 'Conformit√©', 'S√©curit√©'],
                    'challenges': ['R√©gulation', 'S√©curit√©', 'Performance'],
                    'typical_duration': '8-15 mois',
                    'team_size': '8-15 personnes'
                }
            }
        }
    
    async def process_message(self, message: str, context: ConversationContext) -> str:
        """Traite un message utilisateur et g√©n√®re une r√©ponse intelligente"""
        
        self.context = context
        
        # Nettoyage et analyse du message
        cleaned_message = self._clean_message(message)
        intent = self._detect_intent(cleaned_message)
        entities = self._extract_entities(cleaned_message)
        
        # Mise √† jour du contexte
        self._update_conversation_context(message, intent, entities)
        
        # G√©n√©ration de la r√©ponse
        response = await self._generate_response(intent, entities, cleaned_message)
        
        return response
    
    def _clean_message(self, message: str) -> str:
        """Nettoie le message utilisateur"""
        # Suppression des caract√®res sp√©ciaux, normalisation
        cleaned = message.lower().strip()
        # Suppression des mots vides si n√©cessaire
        return cleaned
    
    def _detect_intent(self, message: str) -> ConversationType:
        """D√©tecte l'intention de l'utilisateur"""
        
        intent_scores = {}
        
        for intent_type, patterns in self.intent_patterns.items():
            score = 0
            for pattern in patterns:
                if re.search(pattern, message, re.IGNORECASE):
                    score += 1
            
            if score > 0:
                intent_scores[intent_type] = score
        
        if intent_scores:
            best_intent = max(intent_scores, key=intent_scores.get)
            return ConversationType(best_intent)
        
        return ConversationType.GENERAL_ADVICE
    
    def _extract_entities(self, message: str) -> Dict[str, Any]:
        """Extrait les entit√©s du message"""
        entities = {}
        
        # Extraction de chiffres (budget, √©quipe, dur√©e)
        numbers = re.findall(r'\b\d+\b', message)
        
        # Budget (euros, dollars)
        budget_patterns = [
            r'(\d+)\s*(?:euros?|‚Ç¨)',
            r'(\d+)\s*(?:dollars?|\$)',
            r'budget.*?(\d+)',
            r'(\d+)\s*k‚Ç¨?'
        ]
        
        for pattern in budget_patterns:
            match = re.search(pattern, message, re.IGNORECASE)
            if match:
                budget = int(match.group(1))
                if 'k' in match.group(0).lower():
                    budget *= 1000
                entities['budget'] = budget
                break
        
        # Taille d'√©quipe
        team_patterns = [
            r'(\d+)\s*(?:d√©veloppeurs?|devs?|personnes?)',
            r'√©quipe.*?(\d+)',
            r'(\d+)\s*(?:membres?|gens?)'
        ]
        
        for pattern in team_patterns:
            match = re.search(pattern, message, re.IGNORECASE)
            if match:
                entities['team_size'] = int(match.group(1))
                break
        
        # Dur√©e
        duration_patterns = [
            r'(\d+)\s*(?:mois|months?)',
            r'(\d+)\s*(?:semaines?|weeks?)',
            r'(\d+)\s*(?:jours?|days?)'
        ]
        
        for pattern in duration_patterns:
            match = re.search(pattern, message, re.IGNORECASE)
            if match:
                duration = int(match.group(1))
                if 'semaine' in match.group(0) or 'week' in match.group(0):
                    duration *= 7  # Convertir en jours
                elif 'mois' in match.group(0) or 'month' in match.group(0):
                    duration *= 30  # Convertir en jours
                entities['duration'] = duration
                break
        
        # Technologies mentionn√©es
        technologies = []
        tech_keywords = self.knowledge_base['technologies'].keys()
        for tech in tech_keywords:
            if tech.lower() in message.lower():
                technologies.append(tech)
        
        if technologies:
            entities['technologies'] = technologies
        
        # Domaine du projet
        domain_keywords = {
            'ecommerce': ['e-commerce', 'boutique', 'vente en ligne', 'shop', 'marketplace'],
            'fintech': ['banque', 'finance', 'paiement', 'crypto', 'blockchain'],
            'healthcare': ['sant√©', 'm√©dical', 'h√¥pital', 'patient'],
            'mobile': ['mobile', 'app', 'ios', 'android', 'smartphone']
        }
        
        for domain, keywords in domain_keywords.items():
            for keyword in keywords:
                if keyword in message.lower():
                    entities['domain'] = domain
                    break
            if 'domain' in entities:
                break
        
        return entities
    
    def _update_conversation_context(self, message: str, intent: ConversationType, entities: Dict[str, Any]):
        """Met √† jour le contexte de conversation"""
        if self.context:
            self.context.conversation_history.append({
                'timestamp': datetime.now().isoformat(),
                'message': message,
                'intent': intent.value,
                'entities': entities
            })
            
            # Mise √† jour du contexte projet avec les nouvelles entit√©s
            if self.context.project_context is None:
                self.context.project_context = {}
            
            self.context.project_context.update(entities)
    
    async def _generate_response(self, intent: ConversationType, entities: Dict[str, Any], message: str) -> str:
        """G√©n√®re une r√©ponse intelligente bas√©e sur l'intention"""
        
        try:
            if intent == ConversationType.PROJECT_ANALYSIS:
                return await self._generate_project_analysis(entities)
            elif intent == ConversationType.OPTIMIZATION:
                return await self._generate_optimization_advice(entities)
            elif intent == ConversationType.RISK_ASSESSMENT:
                return await self._generate_risk_assessment(entities)
            elif intent == ConversationType.TEAM_PLANNING:
                return await self._generate_team_advice(entities)
            elif intent == ConversationType.BUDGET_PLANNING:
                return await self._generate_budget_advice(entities)
            else:
                return await self._generate_general_response(message)
                
        except Exception as e:
            return f"ü§ñ D√©sol√©, j'ai rencontr√© un petit probl√®me. Pouvez-vous reformuler votre question ?"
    
    async def _generate_project_analysis(self, entities: Dict[str, Any]) -> str:
        """G√©n√®re une analyse de projet compl√®te"""
        
        # Construction des donn√©es projet pour l'IA pr√©dictive
        project_data = {
            'domain': entities.get('domain', 'web_app'),
            'team_size': entities.get('team_size', 5),
            'budget': entities.get('budget', 100000),
            'technology_stack': entities.get('technologies', ['react', 'node.js']),
            'complexity': 'medium',
            'team_experience': 'mixed'
        }
        
        # Utilisation de l'IA pr√©dictive
        prediction = await ai_predictor.predict_project_outcome(project_data)
        
        # Construction de la r√©ponse
        intro = np.random.choice(self.response_templates['analysis_intro'])
        
        response = f"""{intro}

üéØ **Analyse de votre projet {project_data['domain'].upper()}**

üìä **Pr√©dictions IA:**
‚Ä¢ **Dur√©e estim√©e**: {prediction.predicted_duration:.0f} jours
‚Ä¢ **Co√ªt pr√©vu**: {prediction.predicted_cost:,.0f}‚Ç¨
‚Ä¢ **Probabilit√© de succ√®s**: {prediction.success_probability:.1%}

‚ö° **Facteurs de risque:**"""
        
        for risk_name, risk_score in prediction.risk_factors.items():
            risk_emoji = "üî¥" if risk_score > 0.7 else "üü°" if risk_score > 0.4 else "üü¢"
            risk_label = risk_name.replace('_', ' ').title()
            response += f"\n‚Ä¢ {risk_emoji} {risk_label}: {risk_score:.1%}"
        
        response += f"\n\nüí° **Mes recommandations:**"
        for i, rec in enumerate(prediction.recommendations[:3], 1):
            response += f"\n{i}. {rec}"
        
        # Ajout d'insights domaine
        domain_insights = ai_predictor.get_domain_insights(project_data['domain'])
        if 'error' not in domain_insights:
            response += f"""

üèÜ **Insights domaine {project_data['domain'].upper()}:**
‚Ä¢ Dur√©e type: {domain_insights['average_duration_multiplier']:.1f}x la baseline
‚Ä¢ Taux de succ√®s moyen: {domain_insights['average_success_rate']:.1%}
‚Ä¢ Risques principaux: {', '.join(domain_insights['top_risks'][:3])}"""
        
        return response
    
    async def _generate_optimization_advice(self, entities: Dict[str, Any]) -> str:
        """G√©n√®re des conseils d'optimisation"""
        
        intro = np.random.choice(self.response_templates['optimization_intro'])
        
        optimizations = []
        
        # Optimisations bas√©es sur les entit√©s d√©tect√©es
        if entities.get('team_size', 0) > 8:
            optimizations.append("üèóÔ∏è **√âquipes autonomes**: Divisez en √©quipes plus petites (3-5 personnes) pour plus d'efficacit√©")
        
        if entities.get('budget') and entities.get('budget') < 50000:
            optimizations.append("üí° **Solutions Low-Code**: Explorez des plateformes no-code/low-code pour r√©duire les co√ªts")
        
        if 'technologies' in entities:
            tech_complexity = sum([self.knowledge_base['technologies'].get(tech, {}).get('complexity', 0.5) 
                                 for tech in entities['technologies']])
            if tech_complexity > 1.5:
                optimizations.append("‚ö° **Stack simplifi√©e**: Votre stack est complexe, consid√©rez des alternatives plus simples")
        
        # Optimisations g√©n√©riques
        general_optimizations = [
            "üéØ **MVP First**: Commencez par un MVP pour valider rapidement",
            "üîÑ **Sprints courts**: Adoptez des sprints de 2 semaines maximum",
            "ü§ñ **Automatisation**: Investissez dans les tests et d√©ploiements automatiques",
            "üìà **M√©triques**: Mettez en place un monitoring d√®s le d√©but",
            "üë• **Communication**: Utilisez des outils collaboratifs modernes"
        ]
        
        optimizations.extend(general_optimizations[:3])
        
        response = f"{intro}\n\n"
        for i, opt in enumerate(optimizations, 1):
            response += f"{i}. {opt}\n"
        
        return response
    
    async def _generate_risk_assessment(self, entities: Dict[str, Any]) -> str:
        """G√©n√®re une √©valuation des risques"""
        
        intro = np.random.choice(self.response_templates['risk_intro'])
        
        risks = []
        
        # Risques bas√©s sur le contexte
        if entities.get('team_size', 0) < 3:
            risks.append("‚ö†Ô∏è **√âquipe r√©duite**: Risque de surcharge et de manque de comp√©tences crois√©es")
        
        if entities.get('team_size', 0) > 10:
            risks.append("‚ö†Ô∏è **Grande √©quipe**: Risque de probl√®mes de communication et coordination")
        
        if entities.get('budget', 100000) < 30000:
            risks.append("üí∏ **Budget serr√©**: Risque de compromis sur la qualit√© ou les fonctionnalit√©s")
        
        if 'domain' in entities:
            domain = entities['domain']
            domain_info = self.knowledge_base['domain_expertise'].get(domain, {})
            domain_challenges = domain_info.get('challenges', [])
            for challenge in domain_challenges[:2]:
                risks.append(f"üéØ **D√©fi {domain}**: {challenge}")
        
        # Risques techniques
        if 'technologies' in entities:
            cutting_edge_techs = [tech for tech in entities['technologies'] 
                                if self.knowledge_base['technologies'].get(tech, {}).get('complexity', 0.5) > 0.7]
            if cutting_edge_techs:
                risks.append(f"üîß **Technos complexes**: {', '.join(cutting_edge_techs)} n√©cessitent expertise avanc√©e")
        
        # Mitigations
        mitigations = [
            "üõ°Ô∏è **Tests automatis√©s**: Impl√©mentez une couverture de tests robuste",
            "üìã **Documentation**: Maintenez une documentation √† jour",
            "üîÑ **Revues de code**: Mettez en place des process de revue syst√©matiques",
            "üíæ **Backup plan**: Pr√©parez des solutions de fallback",
            "üìä **Monitoring**: Surveillez les m√©triques critiques en continu"
        ]
        
        response = f"{intro}\n\n**‚ö†Ô∏è Risques identifi√©s:**\n"
        for i, risk in enumerate(risks[:4], 1):
            response += f"{i}. {risk}\n"
        
        response += f"\n**üõ°Ô∏è Strat√©gies de mitigation:**\n"
        for i, mitigation in enumerate(mitigations[:3], 1):
            response += f"{i}. {mitigation}\n"
        
        return response
    
    async def _generate_team_advice(self, entities: Dict[str, Any]) -> str:
        """G√©n√®re des conseils sur l'√©quipe"""
        
        team_size = entities.get('team_size', 5)
        domain = entities.get('domain', 'web_app')
        technologies = entities.get('technologies', [])
        
        response = "üë• **Conseils √©quipe pour votre projet:**\n\n"
        
        # Analyse taille √©quipe
        if team_size < 3:
            response += "‚ö†Ô∏è **√âquipe petite** (< 3 personnes):\n"
            response += "‚Ä¢ Avantage: Communication facile, d√©cisions rapides\n"
            response += "‚Ä¢ Risque: Charge de travail √©lev√©e, manque de sp√©cialisation\n"
            response += "‚Ä¢ Conseil: Priorisez les comp√©tences polyvalentes\n\n"
        elif team_size <= 8:
            response += "‚úÖ **√âquipe optimale** (3-8 personnes):\n"
            response += "‚Ä¢ Parfait pour la plupart des projets\n"
            response += "‚Ä¢ Bonne balance communication/sp√©cialisation\n"
            response += "‚Ä¢ Conseil: D√©finissez clairement les r√¥les\n\n"
        else:
            response += "‚ö†Ô∏è **Grande √©quipe** (> 8 personnes):\n"
            response += "‚Ä¢ Avantage: Plus de comp√©tences, d√©veloppement rapide\n"
            response += "‚Ä¢ Risque: Coordination complexe, communication difficile\n"
            response += "‚Ä¢ Conseil: Divisez en √©quipes plus petites\n\n"
        
        # Composition recommand√©e
        response += "üéØ **Composition recommand√©e:**\n"
        
        domain_recommendations = {
            'ecommerce': ["1 Product Owner", "2-3 D√©veloppeurs Full-Stack", "1 Designer UX", "1 DevOps"],
            'fintech': ["1 Product Owner", "2 D√©veloppeurs Backend", "1 Frontend", "1 Expert S√©curit√©", "1 Compliance"],
            'mobile': ["1 Product Owner", "1 D√©veloppeur iOS", "1 D√©veloppeur Android", "1 Designer", "1 QA"]
        }
        
        recommendations = domain_recommendations.get(domain, 
            ["1 Product Owner", "2 D√©veloppeurs Full-Stack", "1 Designer", "1 QA"])
        
        for rec in recommendations:
            response += f"‚Ä¢ {rec}\n"
        
        # Conseils technologies
        if technologies:
            response += f"\nüîß **Pour votre stack ({', '.join(technologies)}):**\n"
            for tech in technologies:
                tech_info = self.knowledge_base['technologies'].get(tech, {})
                if tech_info.get('complexity', 0.5) > 0.7:
                    response += f"‚Ä¢ {tech}: N√©cessite d√©veloppeur exp√©riment√©\n"
        
        return response
    
    async def _generate_budget_advice(self, entities: Dict[str, Any]) -> str:
        """G√©n√®re des conseils budg√©taires"""
        
        budget = entities.get('budget')
        team_size = entities.get('team_size', 5)
        duration = entities.get('duration', 90)  # 3 mois par d√©faut
        
        response = "üí∞ **Analyse budg√©taire:**\n\n"
        
        if budget:
            # Calcul co√ªt d√©veloppeur moyen (50k‚Ç¨/an = ~400‚Ç¨/jour)
            daily_rate = 400
            total_dev_days = team_size * duration
            estimated_dev_cost = total_dev_days * daily_rate
            
            response += f"üìä **Votre budget**: {budget:,}‚Ç¨\n"
            response += f"üßÆ **Co√ªt d√©veloppement estim√©**: {estimated_dev_cost:,}‚Ç¨\n"
            response += f"üìà **Ratio budget/dev**: {(budget/estimated_dev_cost)*100:.1f}%\n\n"
            
            if budget < estimated_dev_cost * 0.8:
                response += "üî¥ **Budget serr√©** - Consid√©rez:\n"
                response += "‚Ä¢ R√©duire le scope initial\n"
                response += "‚Ä¢ Adopter une approche MVP\n"
                response += "‚Ä¢ Explorer les solutions low-code\n"
                response += "‚Ä¢ D√©caler certaines fonctionnalit√©s\n\n"
            elif budget > estimated_dev_cost * 1.3:
                response += "üü¢ **Budget confortable** - Vous pouvez:\n"
                response += "‚Ä¢ Investir dans la qualit√©\n"
                response += "‚Ä¢ Ajouter des fonctionnalit√©s premium\n"
                response += "‚Ä¢ Renforcer les tests et s√©curit√©\n"
                response += "‚Ä¢ Pr√©voir une marge pour l'√©volution\n\n"
            else:
                response += "üü° **Budget r√©aliste** - Recommandations:\n"
                response += "‚Ä¢ Planifiez avec une marge de 20%\n"
                response += "‚Ä¢ Priorisez rigoureusement les features\n"
                response += "‚Ä¢ Surveillez l'avancement de pr√®s\n\n"
        
        # R√©partition budget type
        response += "üìã **R√©partition budget recommand√©e:**\n"
        response += "‚Ä¢ 60-70% D√©veloppement\n"
        response += "‚Ä¢ 10-15% Design/UX\n"
        response += "‚Ä¢ 10-15% Infrastructure/DevOps\n"
        response += "‚Ä¢ 5-10% Tests/QA\n"
        response += "‚Ä¢ 5-10% Marge/Impr√©vu\n"
        
        return response
    
    async def _generate_general_response(self, message: str) -> str:
        """G√©n√®re une r√©ponse g√©n√©rale"""
        
        general_responses = [
            "ü§ñ Je suis l√† pour vous aider avec votre projet ! Parlez-moi de votre id√©e, votre √©quipe, votre budget ou vos pr√©occupations.",
            "‚ú® Excellent ! Je peux vous aider avec l'analyse de projet, l'optimisation, les risques, la planification d'√©quipe ou le budget. Que souhaitez-vous explorer ?",
            "üéØ Int√©ressant ! Donnez-moi plus de d√©tails sur votre projet et je pourrai vous fournir une analyse personnalis√©e."
        ]
        
        return np.random.choice(general_responses)
    
    def get_conversation_summary(self) -> Dict[str, Any]:
        """Retourne un r√©sum√© de la conversation"""
        if not self.context or not self.context.conversation_history:
            return {'error': 'Aucune conversation en cours'}
        
        history = self.context.conversation_history
        intents = [entry['intent'] for entry in history]
        entities_mentioned = {}
        
        for entry in history:
            for key, value in entry['entities'].items():
                entities_mentioned[key] = value
        
        return {
            'messages_count': len(history),
            'main_intents': list(set(intents)),
            'project_context': entities_mentioned,
            'last_update': history[-1]['timestamp'] if history else None
        }


# Instance globale
ai_assistant = AIConversationalAssistant()