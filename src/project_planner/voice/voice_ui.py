"""
Advanced Voice UI Components for PlannerIA
Interface vocale intelligente pour Streamlit
"""

import streamlit as st
import time
import json
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
import threading

try:
    from .text_to_speech import (
        get_voice_synthesizer,
        SpeechConfig,
        VoiceType,
        SpeechRate
    )
    from .voice_processor import (
        get_voice_processor,
        CommandIntent,
        ProcessingResult
    )
    
    # Try to import speech recognizer, but make it optional
    try:
        from .speech_recognizer import (
            get_voice_recognizer, 
            VoiceCommand, 
            RecognitionState, 
            Language
        )
        SPEECH_RECOGNITION_AVAILABLE = True
    except ImportError:
        SPEECH_RECOGNITION_AVAILABLE = False
        
    VOICE_AVAILABLE = True  # TTS and processing are available
except ImportError as e:
    VOICE_AVAILABLE = False
    SPEECH_RECOGNITION_AVAILABLE = False
    
logger = logging.getLogger(__name__)

class VoiceUIManager:
    """Gestionnaire de l'interface vocale pour Streamlit"""
    
    def __init__(self):
        self.is_initialized = False
        self.last_command_time = None
        self.voice_session_active = False
        
        # Callbacks pour actions
        self.action_callbacks = {
            CommandIntent.GENERATE_PLAN: None,
            CommandIntent.EXPORT_PDF: None,
            CommandIntent.EXPORT_CSV: None,
            CommandIntent.START_MONITORING: None,
            CommandIntent.STOP_MONITORING: None,
            CommandIntent.SHOW_ANALYTICS: None,
            CommandIntent.SHOW_DASHBOARD: None,
            CommandIntent.READ_RESULTS: None
        }
        
    def initialize_voice_system(self):
        """Initialiser le syst√®me vocal"""
        if not VOICE_AVAILABLE:
            st.error("‚ùå Modules vocaux non disponibles")
            return False
            
        try:
            # Initialiser les composants de base (TTS et processing)
            if 'voice_synthesizer' not in st.session_state:
                config = SpeechConfig(
                    voice_type=VoiceType.FEMALE,
                    rate=SpeechRate.NORMAL.value,
                    volume=0.8
                )
                st.session_state.voice_synthesizer = get_voice_synthesizer(config)
                
            if 'voice_processor' not in st.session_state:
                st.session_state.voice_processor = get_voice_processor()
                self._setup_voice_handlers()
            
            # Reconnaissance vocale optionnelle
            if SPEECH_RECOGNITION_AVAILABLE:
                if 'voice_recognizer' not in st.session_state:
                    st.session_state.voice_recognizer = get_voice_recognizer(Language.FRENCH)
            else:
                st.warning("‚ö†Ô∏è Reconnaissance vocale indisponible (pyaudio manquant)")
                
            self.is_initialized = True
            return True
            
        except Exception as e:
            st.error(f"‚ùå Erreur initialisation syst√®me vocal: {e}")
            logger.error(f"Erreur initialisation voice system: {e}")
            return False
            
    def _setup_voice_handlers(self):
        """Configurer les gestionnaires de commandes vocales"""
        processor = st.session_state.voice_processor
        
        # Handler pour g√©n√©ration de plan
        def handle_generate_plan(params, original_text):
            if 'project_description' in params:
                st.session_state.voice_command_result = {
                    'action': 'generate_plan',
                    'description': params['project_description'],
                    'timestamp': datetime.now().isoformat()
                }
            return {'action': 'plan_generation_started', 'response': 'G√©n√©ration du plan d√©marr√©e'}
            
        # Handler pour export PDF
        def handle_export_pdf(params, original_text):
            st.session_state.voice_command_result = {
                'action': 'export_pdf',
                'timestamp': datetime.now().isoformat()
            }
            return {'action': 'pdf_export_started', 'response': 'Export PDF d√©marr√©'}
            
        # Handler pour surveillance
        def handle_start_monitoring(params, original_text):
            st.session_state.voice_command_result = {
                'action': 'start_monitoring',
                'timestamp': datetime.now().isoformat()
            }
            return {'action': 'monitoring_started', 'response': 'Surveillance d√©marr√©e'}
            
        # Handler pour lecture r√©sultats
        def handle_read_results(params, original_text):
            if 'last_analysis' in st.session_state:
                synthesizer = st.session_state.voice_synthesizer
                synthesizer.speak_analysis_result(st.session_state.last_analysis, priority=2)
            return {'action': 'results_read', 'response': 'Lecture des r√©sultats en cours'}
            
        # Enregistrer les handlers
        processor.register_action_handler(CommandIntent.GENERATE_PLAN, handle_generate_plan)
        processor.register_action_handler(CommandIntent.EXPORT_PDF, handle_export_pdf)
        processor.register_action_handler(CommandIntent.START_MONITORING, handle_start_monitoring)
        processor.register_action_handler(CommandIntent.READ_RESULTS, handle_read_results)
        
    def render_voice_control_panel(self):
        """Afficher le panneau de contr√¥le vocal"""
        if not self.initialize_voice_system():
            return
            
        st.markdown("---")
        st.markdown("### üé§ Interface Vocale Intelligente")
        
        # Section principale : RECONNAISSANCE VOCALE (STT)
        st.markdown("#### üé§ Reconnaissance Vocale (STT) - Parlez √† PlannerIA")
        
        stt_col1, stt_col2 = st.columns([3, 2])
        
        with stt_col1:
            # Le bouton principal pour parler
            if st.button("üé§ PARLER √Ä PLANNERAI", key="main_voice_btn", help="Cliquez et parlez maintenant!", type="primary"):
                self._handle_voice_listen()
                
            # Instructions claires
            st.info("üí° Cliquez le bouton et dites par exemple : 'Je souhaite cr√©er une application mobile'")
            
        with stt_col2:
            # √âtat reconnaissance
            if 'voice_recognizer' in st.session_state:
                recognizer = st.session_state.voice_recognizer
                if recognizer.is_listening:
                    st.error("üî¥ **√âCOUTE EN COURS** - Parlez maintenant!")
                else:
                    st.success("‚úÖ **PR√äT √Ä √âCOUTER**")
            
        st.markdown("---")
        
        # Section secondaire : SYNTH√àSE VOCALE (TTS) - Tests et contr√¥les
        with st.expander("üîä Contr√¥les Synth√®se Vocale (TTS) - PlannerIA vous parle", expanded=False):
            col1, col2, col3 = st.columns([2, 2, 2])
            
            with col1:
                st.markdown("**üéØ Tests TTS**")
            
                # Boutons de test TTS
                btn_col1, btn_col2 = st.columns(2)
                
                with btn_col1:
                    # Bouton test vocal long
                    if st.button("üîä Test Long", key="voice_test_btn"):
                        self._handle_voice_test()
                        
                with btn_col2:
                    # Bouton test rapide
                    if st.button("‚ö° Test Rapide", key="voice_test_short_btn", help="Test TTS court"):
                        self._handle_voice_test_short()
                
            with col2:
                st.markdown("**üîß Contr√¥les TTS**")
                
                control_col1, control_col2 = st.columns(2)
                
                with control_col1:
                    # Bouton stop vocal
                    if st.button("‚èπÔ∏è Stop TTS", key="voice_stop_btn", help="Arr√™ter la synth√®se vocale"):
                        self._handle_voice_stop()
                        st.rerun()
                        
                with control_col2:
                    # Bouton vider queue
                    if st.button("üóëÔ∏è Vider Queue", key="voice_clear_btn", help="Vider la file d'attente"):
                        self._handle_voice_clear()
                        st.rerun()
                        
            with col3:
                st.markdown("**üìä √âtat TTS**")
                
                # √âtat TTS en temps r√©el
                if 'voice_synthesizer' in st.session_state:
                    synthesizer = st.session_state.voice_synthesizer
                    if synthesizer.is_speaking:
                        st.error("üîä **TTS ACTIF**")
                    elif synthesizer.speech_queue.qsize() > 0:
                        st.warning(f"üìù Queue: {synthesizer.speech_queue.qsize()}")
                    else:
                        st.success("üîá **TTS LIBRE**")
                        
                # Bouton √©tat d√©taill√©
                if st.button("üìä √âtat D√©taill√©", key="voice_status_btn", help="Diagnostic complet"):
                    self._show_voice_status()
            
            # Configuration vocale dans l'expander
            st.markdown("**‚öôÔ∏è Configuration Voix**")
            
            config_col1, config_col2 = st.columns(2)
            
            with config_col1:
                voice_type = st.selectbox(
                    "Type de voix",
                    ["female", "male", "auto"],
                    key="voice_type_select"
                )
                
            with config_col2:
                speech_rate = st.slider(
                    "Vitesse (mots/min)",
                    120, 250, 180,
                    key="voice_rate_slider"
                )
            
        # Zone de statut vocal
        self._render_voice_status()
        
        # Historique des commandes
        self._render_command_history()
        
        # Aide contextuelle sp√©cifique STT vs TTS
        self._render_voice_help_stt_tts()
        
    def _handle_voice_listen(self):
        """G√©rer l'√©coute d'une commande vocale"""
        if not self.is_initialized:
            st.error("Syst√®me vocal non initialis√©")
            return
            
        if not SPEECH_RECOGNITION_AVAILABLE:
            st.error("‚ùå Reconnaissance vocale non disponible")
            return
            
        try:
            with st.spinner("üé§ √âcoute en cours... Parlez maintenant"):
                recognizer = st.session_state.voice_recognizer
                result = recognizer.recognize_single_command(timeout=5.0)
                
            if result.success and result.command:
                # Traiter la commande
                processor = st.session_state.voice_processor
                processing_result = processor.process_command(result.command.text)
                
                # Afficher le r√©sultat
                if processing_result.success:
                    st.success(f"‚úÖ Commande comprise: '{result.command.text}'")
                    st.info(f"üéØ Action: {processing_result.intent.value}")
                    
                    # Feedback vocal
                    synthesizer = st.session_state.voice_synthesizer
                    synthesizer.speak_text(
                        processing_result.response_text or "Commande ex√©cut√©e",
                        priority=1
                    )
                    
                else:
                    st.warning(f"‚ö†Ô∏è Commande non comprise: '{result.command.text}'")
                    st.error(f"Erreur: {processing_result.error}")
                    
            else:
                st.error(f"‚ùå Reconnaissance √©chou√©e: {result.error}")
                
        except Exception as e:
            st.error(f"‚ùå Erreur √©coute vocale: {e}")
            logger.error(f"Erreur voice listen: {e}")
            
    def _handle_voice_test(self):
        """Tester la synth√®se vocale"""
        try:
            synthesizer = st.session_state.voice_synthesizer
            
            # Test avec message plus long pour pouvoir tester le stop
            test_text = """Test de synth√®se vocale PlannerIA. 
            Le syst√®me est maintenant parfaitement op√©rationnel avec reconnaissance vocale, 
            synth√®se de texte, traitement des commandes naturelles en fran√ßais, 
            et contr√¥les avanc√©s incluant arr√™t et vidage de queue. 
            Vous pouvez maintenant interagir vocalement avec l'intelligence artificielle."""
            
            synthesizer.speak_text(test_text, priority=2)
            st.success("üîä Test vocal long lanc√© - Utilisez Stop pour l'interrompre")
            
        except Exception as e:
            st.error(f"‚ùå Erreur test vocal: {e}")
            
    def _handle_voice_test_short(self):
        """Test TTS rapide"""
        try:
            synthesizer = st.session_state.voice_synthesizer
            test_text = "Test rapide TTS PlannerIA."
            synthesizer.speak_text(test_text, priority=2)
            st.success("‚ö° Test rapide lanc√©")
            
        except Exception as e:
            st.error(f"‚ùå Erreur test rapide: {e}")
            
    def _show_voice_status(self):
        """Afficher l'√©tat d√©taill√© du syst√®me vocal"""
        try:
            if 'voice_synthesizer' not in st.session_state:
                st.warning("‚ö†Ô∏è Synth√©tiseur non initialis√©")
                return
                
            synthesizer = st.session_state.voice_synthesizer
            stats = synthesizer.get_stats()
            
            with st.expander("üìä √âtat D√©taill√© TTS", expanded=True):
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric("üîä Actif", synthesizer.is_speaking)
                    st.metric("üìù Queue", synthesizer.speech_queue.qsize())
                    
                with col2:
                    st.metric("‚úÖ Succ√®s", stats.get('successful_speeches', 0))
                    st.metric("‚ùå √âchecs", stats.get('failed_speeches', 0))
                    
                with col3:
                    st.metric("üìä Total", stats.get('total_speeches', 0))
                    st.metric("üé§ Voix", stats.get('available_voices', 0))
                
                # Afficher la derni√®re synth√®se
                if 'last_speech' in stats and stats['last_speech']:
                    last = stats['last_speech']
                    st.text(f"Derni√®re: {last.get('text', '')[:50]}...")
                    
        except Exception as e:
            st.error(f"‚ùå Erreur affichage statut: {e}")
            
    def _handle_voice_stop(self):
        """Arr√™ter la synth√®se vocale en cours"""
        try:
            if 'voice_synthesizer' not in st.session_state:
                st.warning("‚ö†Ô∏è Synth√©tiseur non initialis√©")
                return
                
            synthesizer = st.session_state.voice_synthesizer
            was_speaking = synthesizer.is_speaking
            queue_size = synthesizer.speech_queue.qsize()
            
            # Arr√™ter la synth√®se
            synthesizer.stop_current_speech()
            
            if was_speaking or queue_size > 0:
                st.success(f"‚èπÔ∏è Synth√®se arr√™t√©e (√©tait actif: {was_speaking}, queue: {queue_size})")
            else:
                st.info("‚èπÔ∏è Aucune synth√®se en cours √† arr√™ter")
                
        except Exception as e:
            st.error(f"‚ùå Erreur arr√™t vocal: {e}")
            logger.error(f"Erreur stop voice: {e}")
            
    def _handle_voice_clear(self):
        """Vider la queue de synth√®se"""
        try:
            if 'voice_synthesizer' not in st.session_state:
                st.warning("‚ö†Ô∏è Synth√©tiseur non initialis√©")
                return
                
            synthesizer = st.session_state.voice_synthesizer
            queue_size_before = synthesizer.speech_queue.qsize()
            
            # Vider la queue
            synthesizer.clear_queue()
            
            if queue_size_before > 0:
                st.success(f"üóëÔ∏è Queue vid√©e ({queue_size_before} √©l√©ments supprim√©s)")
            else:
                st.info("üóëÔ∏è Queue d√©j√† vide")
                
        except Exception as e:
            st.error(f"‚ùå Erreur vidage queue: {e}")
            logger.error(f"Erreur clear voice: {e}")
            
    def _render_voice_stats(self):
        """Afficher les statistiques vocales"""
        try:
            if 'voice_recognizer' in st.session_state:
                recognizer_stats = st.session_state.voice_recognizer.get_stats()
                st.metric("Commandes", recognizer_stats['total_commands'])
                st.metric("Succ√®s", f"{recognizer_stats['success_rate']:.0%}")
                
            if 'voice_synthesizer' in st.session_state:
                synthesizer_stats = st.session_state.voice_synthesizer.get_stats()
                st.metric("Synth√®ses", synthesizer_stats['total_speeches'])
                
        except Exception as e:
            logger.error(f"Erreur stats vocales: {e}")
            
    def _render_voice_status(self):
        """Afficher le statut du syst√®me vocal"""
        st.markdown("#### üîç Statut Syst√®me Vocal")
        
        status_col1, status_col2 = st.columns(2)
        
        with status_col1:
            if self.is_initialized:
                st.success("‚úÖ Syst√®me vocal op√©rationnel")
            else:
                st.error("‚ùå Syst√®me vocal non initialis√©")
                
        with status_col2:
            # Indicateur temps r√©el
            if 'voice_recognizer' in st.session_state:
                recognizer = st.session_state.voice_recognizer
                if recognizer.is_listening:
                    st.info("üî¥ √âcoute active")
                else:
                    st.info("‚ö™ En attente")
                    
            # Indicateur TTS
            if 'voice_synthesizer' in st.session_state:
                synthesizer = st.session_state.voice_synthesizer
                if synthesizer.is_speaking:
                    st.info("üîä TTS actif")
                elif synthesizer.speech_queue.qsize() > 0:
                    st.info(f"üìù Queue: {synthesizer.speech_queue.qsize()}")
                else:
                    st.info("üîá TTS libre")
                    
    def _render_command_history(self):
        """Afficher l'historique des commandes"""
        if 'voice_processor' not in st.session_state:
            return
            
        with st.expander("üìú Historique des Commandes Vocales", expanded=False):
            processor = st.session_state.voice_processor
            
            if hasattr(processor, 'context_history') and processor.context_history:
                # Afficher les 5 derni√®res commandes
                recent_commands = processor.context_history[-5:]
                
                for i, cmd in enumerate(reversed(recent_commands), 1):
                    success_icon = "‚úÖ" if cmd['success'] else "‚ùå"
                    st.markdown(f"""
                    **{i}.** {success_icon} `{cmd['command']}`  
                    *Intent: {cmd['intent']} | Confiance: {cmd['confidence']:.2f}*
                    """)
            else:
                st.info("Aucune commande dans l'historique")
                
    def _render_voice_help_stt_tts(self):
        """Aide sp√©cifique STT vs TTS"""
        with st.expander("‚ùì Comprendre STT vs TTS - Comment utiliser la voix", expanded=True):
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("""
                ### üé§ **STT (Speech-to-Text)**
                **= VOUS PARLEZ ‚Üí PlannerIA comprend**
                
                **Comment faire :**
                1. Cliquez "üé§ PARLER √Ä PLANNERAI"  
                2. Attendez le signal "üî¥ √âCOUTE EN COURS"
                3. **Parlez clairement** votre demande
                4. PlannerIA analyse et r√©pond
                
                **Exemples de phrases :**
                - *"Je souhaite cr√©er une application mobile"*
                - *"G√©n√®re un plan pour un site e-commerce"*
                - *"J'ai besoin d'aide pour un projet IA"*
                - *"Montre-moi les analyses"*
                """)
                
            with col2:
                st.markdown("""
                ### üîä **TTS (Text-to-Speech)**
                **= PlannerIA vous parle ‚Üí VOUS entendez**
                
                **Utilisations :**
                - PlannerIA **lit** les r√©sultats d'analyse
                - **Notifications** vocales d'alertes
                - **Tests** de fonctionnement vocal
                - **Feedback** audio des actions
                
                **Contr√¥les disponibles :**
                - ‚ö° Test Rapide (court)
                - üîä Test Long (pour tester Stop)
                - ‚èπÔ∏è Stop TTS (arr√™ter imm√©diatement)
                - üóëÔ∏è Vider Queue (nettoyer)
                """)
                
            st.info("üí° **R√©sum√© simple :** Cliquez üé§ PARLER pour que PlannerIA vous **√©coute** ‚Üí Il vous **r√©pond** en vocal (TTS) ET texte !")
            
        # Commandes d√©taill√©es dans un expander s√©par√©
        with st.expander("üìù Liste Compl√®te des Commandes Vocales", expanded=False):
            st.markdown("""
            **üéØ G√©n√©ration de plans:**
            - "Je souhaite r√©aliser un projet [description]"
            - "G√©n√®re un plan pour [description]"
            - "J'ai besoin d'un plan pour application mobile"
            - "Comment faire une plateforme web"
            
            **üìä Navigation:**
            - "Montre les analyses" / "Affiche le dashboard"
            - "Va √† la surveillance" / "Ouvre le monitoring"
            
            **üìÅ Actions:**
            - "Exporte en PDF" / "Exporte en CSV"
            - "D√©marre la surveillance" / "Arr√™te le monitoring"
            
            **üîä Informations:**
            - "Lis-moi les r√©sultats" / "Quel est le statut"
            - "Aide" / "Comment utiliser"
            """)
            
    def render_voice_floating_button(self):
        """Bouton flottant pour activation rapide"""
        # CSS pour bouton flottant
        st.markdown("""
        <style>
        .voice-float-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: all 0.3s ease;
        }
        .voice-float-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
        }
        </style>
        """, unsafe_allow_html=True)
        
    def handle_voice_command_results(self):
        """Traiter les r√©sultats de commandes vocales stock√©s en session"""
        if 'voice_command_result' not in st.session_state:
            return
            
        result = st.session_state.voice_command_result
        action = result.get('action')
        
        # Traiter selon le type d'action
        if action == 'generate_plan':
            description = result.get('description', '')
            if description:
                # D√©clencher g√©n√©ration de plan via session state
                st.session_state.voice_plan_request = description
                st.rerun()
                
        elif action == 'export_pdf':
            # D√©clencher export PDF
            st.session_state.voice_export_pdf = True
            st.rerun()
            
        elif action == 'start_monitoring':
            # D√©clencher surveillance
            st.session_state.voice_start_monitoring = True
            st.rerun()
            
        # Nettoyer apr√®s traitement
        del st.session_state.voice_command_result

# Fonctions utilitaires pour int√©gration Streamlit
def render_voice_interface():
    """Fonction principale pour afficher l'interface vocale"""
    if not VOICE_AVAILABLE:
        st.warning("‚ö†Ô∏è Interface vocale non disponible - modules manquants")
        return
        
    if 'voice_ui_manager' not in st.session_state:
        st.session_state.voice_ui_manager = VoiceUIManager()
        
    manager = st.session_state.voice_ui_manager
    manager.render_voice_control_panel()
    manager.handle_voice_command_results()

def render_voice_floating_controls():
    """Afficher les contr√¥les vocaux flottants"""
    if not VOICE_AVAILABLE:
        return
        
    if 'voice_ui_manager' not in st.session_state:
        st.session_state.voice_ui_manager = VoiceUIManager()
        
    manager = st.session_state.voice_ui_manager
    manager.render_voice_floating_button()

def is_voice_available() -> bool:
    """V√©rifier si le syst√®me vocal est disponible"""
    return VOICE_AVAILABLE

def get_voice_stats() -> Dict[str, Any]:
    """Obtenir les statistiques vocales consolid√©es"""
    if not VOICE_AVAILABLE:
        return {'available': False}
        
    stats = {'available': True}
    
    try:
        if 'voice_recognizer' in st.session_state:
            stats['recognition'] = st.session_state.voice_recognizer.get_stats()
            
        if 'voice_synthesizer' in st.session_state:
            stats['synthesis'] = st.session_state.voice_synthesizer.get_stats()
            
        if 'voice_processor' in st.session_state:
            stats['processing'] = st.session_state.voice_processor.get_stats()
            
    except Exception as e:
        logger.error(f"Erreur collecte stats vocales: {e}")
        stats['error'] = str(e)
        
    return stats